- 10진법 <-> 2진법 이렇게 숫자가 아닌 26진법(a~z)같은 문자들도 진법 변환처럼 숫자<->문자를 변환가능
	- 단, 0을 처리하는 부분에서 차이가 있음.
- 사실 문제에서는 이 같은 사실을 숨겨놓지만 직접 나열해보면 규칙이 보이고 결국 그 규칙은 진법포맷과 비슷한걸 느끼게 된다.
	- [[(n진법) 봉인된 주문]] 문제 참고할것

## 26진법 전환 코드
- `0` 이 없는것의 파급성 고려 해야 함.
```java
	/**
     * 문자열을 1-26 기반의 26진법 숫자로 변환합니다.
     * 예: "a" -> 1, "z" -> 26, "aa" -> 27, "ab" -> 28
     */
    public long getNumber(String str) {
        long number = 0;
        long powerOf26 = 1; // 26^0, 26^1, 26^2, ...
        // 문자열의 오른쪽부터 왼쪽으로 순회하며 계산해야 합니다.
        for (int i = str.length() - 1; i >= 0; i--) {
            // 'a'는 1, 'b'는 2, ..., 'z'는 26
            long charValue = str.charAt(i) - 'a' + 1;
            number += charValue * powerOf26;
            powerOf26 *= 26;
        }
        return number;
    }
    
	/*
     * 1-26 기반의 26진법 숫자를 문자열로 변환합니다.
     * 예: 1 -> "a", 26 -> "z", 27 -> "aa", 28 -> "ab"
     */
    public String getString(long number) {
        StringBuilder sb = new StringBuilder();
        // number가 0보다 클 때까지 반복합니다.
        while (number > 0) {
            // 0-25 범위의 나머지를 얻기 위해 (number - 1)을 합니다.
            // 이렇게 하면 1~26이 0~25에 매핑됩니다. (1->0, 26->25)
            long remainder = (number - 1) % 26;
            sb.append((char) ('a' + remainder));

            // 다음 자릿수 계산을 위해 (number - 1)을 26으로 나눕니다.
            number = (number - 1) / 26;
        }
        // 결과는 역순으로 만들어지므로 뒤집어서 반환합니다.
        return sb.reverse().toString();
    }
```

## 2,10,16 진법과 26진법(알파벳) 차이
> Gemini 참고
### 무엇이 비슷한가? (2진법 -> 10진법과 유사한 점)

두 시스템 모두 위치 기수법(Positional Number System)을 사용한다는 점에서 매우 유사합니다.

*   **위치 기수법이란?** 숫자의 값이 그 숫자의 종류와 **위치**에 따라 결정되는 방식입니다.

예를 들어 10진수 `123`은 다음과 같이 계산됩니다.
`123` = `1` * 10² + `2` * 10¹ + `3` * 10⁰

2진수 `1101`은 다음과 같이 계산됩니다.
`1101` = `1` * 2³ + `1` * 2² + `0` * 2¹ + `1` * 2⁰

마찬가지로, 이 문제의 문자열 `"ba"`는 다음과 같이 계산됩니다. (`b`=2, `a`=1)
`"ba"` = `b` * 26¹ + `a` * 26⁰ = `2` * 26 + `1` * 1 = 53

**여기까지 보면, 단순히 밑(base)이 10이나 2 대신 26으로 바뀐 것처럼 보입니다.** 이 점에서는 2진법을 10진법으로 바꾸는 것과 원리가 완전히 동일합니다.

### 무엇이 다른가? (결정적인 차이점)

가장 큰 차이점은 **'0'의 존재 유무**입니다.

1.  **일반적인 진법 (2진법, 10진법 등)**
    *   **0부터 시작**하는 숫자를 사용합니다.
    *   10진법: `0, 1, 2, 3, 4, 5, 6, 7, 8, 9` (10개)
    *   2진법: `0, 1` (2개)
    *   `0`은 자릿수를 채우는 중요한 역할을 합니다. 9 다음이 `10`이 되는 것은 1의 자리를 `0`으로 초기화하고 10의 자리를 하나 올리기 때문입니다.

2.  **이 문제의 26진법 (Bijective base-26)**
    *   **1부터 시작**하는 "숫자"(문자)를 사용합니다.
    *   `a(1), b(2), c(3), ..., z(26)` (26개)
    *   `0`에 해당하는 개념이 없습니다.
    *   그래서 26번째 수 `z` 다음에 `a0` 같은 것이 오는 게 아니라, 바로 자릿수가 올라간 `aa`가 옵니다.

==이 차이 때문에 숫자와 문자열을 서로 변환하는 계산법이 미묘하게 달라지는 것입니다.==

*   **숫자 -> 문자열 변환 시**: `(number - 1)`을 해주는 이유가 바로 이 '0'의 부재를 보정하여 일반적인 진법 변환처럼 계산하기 위함입니다. 1~26의 범위를 0~25의 범위로 맞춰주는 것이죠.
	* ==이해가 잘 안감;;;==

### 가장 좋은 비유: 엑셀(Excel) 시트의 열 이름

이 문제의 시스템은 엑셀 시트의 열 이름과 정확히 같습니다.
`A, B, C, ..., Z` (1~26)
그다음은 `AA, AB, AC, ...` (27, 28, 29, ...)
그다음은 `AZ` 다음에 `BA`가 옵니다.

엑셀에서도 '0번째 열'이라는 개념은 존재하지 않죠.

### 요약 비교

| 특징 | 일반적인 진법 (예: 10진법) | 문제의 26진법 (Bijective Base-26) |
| :--- | :--- | :--- |
| **기본 원리** | 위치 기수법 | 위치 기수법 |
| **사용 기호** | 0, 1, 2, ..., 9 | a(1), b(2), ..., z(26) |
| **'0'의 존재**| **있음** (자릿수 채움 역할) | **없음** |
| **카운팅** | 9 다음은 10 (자릿수 올림) | z(26) 다음은 aa(27) (자릿수 올림) |
| **유사한 예** | 우리가 일상에서 쓰는 모든 숫자 | 엑셀 열 이름 |

**결론적으로, "문자열을 숫자로 바꾸는 것은 2진법을 10진법으로 바꾸는 것과 거의 같지만, 0이 없는 특별한 규칙을 따른다"라고 이해하시면 완벽합니다.**