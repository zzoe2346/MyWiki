---
tags:
  - B
  - 문자열
  - 취이코전/8
created: 2025-09-13
reviewed: 2025-09-26
URL: https://school.programmers.co.kr/learn/courses/30/lessons/60057
반복수: "2"
복습: true
중요성: true
레이팅: Lv. 2
메모:
---
```
import java.util.*;
class Solution {
    public int solution(String s) {
        int min = Integer.MAX_VALUE;
        for(int length = 1;length <= s.length();length++){
            min = Math.min(min, compress(length, s));
        }
        return min;
    }
    
    private static int compress(int length, String source){
        String pre = "";
        int cnt = 0;
        StringBuilder sb = new StringBuilder();
        for(String token : split(length, source)){
            if(pre.equals(token)){
                ++cnt;
            }else{
                if(cnt > 1){
                    sb.append(cnt);
                }
                sb.append(pre);
                pre = token;
                cnt = 1;
            }
        }        
        if(cnt > 1){
            sb.append(cnt);
        }
        sb.append(pre);
        return sb.toString().length();
    }
    
    private static List<String> split(int length, String source){
        List<String> tokens = new ArrayList<>();
        for(int i=0;i<source.length();i+=length){
            int lastIndex = i + length;
            if(lastIndex > source.length()) lastIndex = source.length();
            tokens.add(source.substring(i,lastIndex));
        }
        //System.out.print(tokens);
        return tokens;
    }
}
```

## 250926 
나 자신을 못믿었군;;;
- 30분내로 못품
- 혼자 못품
- 틀림
- 마지막 토큰 처리 누락.
```내꺼 틀림
import java.util.*;
class Solution {
    public int solution(String s) {
        
        //l은 자를 문자열 길이
        int ans = Integer.MAX_VALUE;
        for(int l=1 ; l<=s.length() ; l++){
            List<String> tokens = new ArrayList<>();
            for(int i=0 ; i<s.length() ; i+=l){
                if(i+l > s.length()){
                    tokens.add(s.substring(i));
                    break;
                }
                tokens.add(s.substring(i, i+l));
            }
            
            //토큰 얻음. 이제 압축한다.
            String preToken = "";
            int seqCount = 0;
            StringBuilder sb = new StringBuilder();
            for(String token : tokens){
                //현재 토큰이 이전과 같다면 seq ++, 
                if(token.equals(preToken)){
                    seqCount++;
                }else{// a a b c
                    //이때는 압축시킨다. 압축한거 붙이면된다.
                    if(seqCount >= 2){
                        sb.append(seqCount);
                    }
                    seqCount = 1;
                    preToken = token;
                    sb.append(token);
                }
            }
            ans=Math.min(ans,sb.length());
        }
         return ans;
    }
    //문자열 잘라 압축한 문자열중 가장 짧은것.
    //브루트포스: 1~n길이까지 잘라본다...
    //n개로 자른다. replaceAll쓰면 안된다. 처음부터 무조건 짤라야하낟.
    //처음부터 짜른다면 자르는건 문제가 안되고 이걸 압축할때...
    //abc 가 2개 연속있다면 2abc -> 2(이거 길이계산) + 3(자른문자열 길이)
    //1개면 그대로 둔다.
}
```

```gpt
import java.util.*;

class Solution {
    public int solution(String s) {
        int ans = Integer.MAX_VALUE;

        for (int l = 1; l <= s.length(); l++) {
            List<String> tokens = new ArrayList<>();
            for (int i = 0; i < s.length(); i += l) {
                if (i + l > s.length()) {
                    tokens.add(s.substring(i));
                } else {
                    tokens.add(s.substring(i, i + l));
                }
            }

            String preToken = "";
            int seqCount = 0;
            StringBuilder sb = new StringBuilder();

            for (String token : tokens) {
                if (token.equals(preToken)) {
                    seqCount++;
                } else {
                    if (!preToken.equals("")) { // 이전 토큰 처리
                        if (seqCount > 1) sb.append(seqCount);
                        sb.append(preToken);
                    }
                    preToken = token;
                    seqCount = 1;
                }
            }

            // 마지막 토큰 처리
            if (!preToken.equals("")) {
                if (seqCount > 1) sb.append(seqCount);
                sb.append(preToken);
            }

            ans = Math.min(ans, sb.length());
        }

        return ans;
    }
}

```