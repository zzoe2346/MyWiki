---
tags:
  - 투포인터
  - 취이코전/52
created: 2025-09-13
reviewed:
URL: https://school.programmers.co.kr/learn/courses/30/lessons/67258
반복수: "0"
복습:
중요성:
레이팅: Lv. 3
메모:
---
```
import java.util.*;

class Solution {
    public int[] solution(String[] gems) {
        Set<String> gemSet = new HashSet<>();
        for(String gem : gems){
            gemSet.add(gem);
        }
        int targetNumber = gemSet.size();
        Map<String, Integer> gemMap = new HashMap<>();
        
        //left는 버리기, right는 얻기 둘 다 우측방향으로 간다.
        int left = 0;
        int right = gems.length - 1;
        
        int l=0;//s
        int r=0;//e
        gemMap.put(gems[0],1);
        while(r < gems.length){//r이냐 l이냐...
            //목표 보석수 달성!
            if(gemMap.keySet().size() == targetNumber){
                //기존 길이보다 작은가?
                if(right - left + 1 > r - l + 1){
                    //기존 기준 길이보다 작다. 그러면 갱신해야지
                    right=r;
                    left=l;
                }
                
                //갱신 하든 안하든 맵을 수정한다.left가 늘어나면서 기존꺼 버린다.
                gemMap.put(gems[l], gemMap.get(gems[l]) - 1);
                if(gemMap.get(gems[l]) == 0) gemMap.remove(gems[l]);
                l++;
            }else if(r+1 < gems.length){
                //목표 달성 못했으니 더 먹어야 된다 보석을
                //그려려면 r을 우측으로 옮기자. 옮기면 맵을 갱신해준다.
                r++;
                gemMap.put(gems[r], gemMap.getOrDefault(gems[r],0) + 1);
            }else{
                break;
            }
        }
        
        return new int[]{left+1, right +1};
    }
}

//모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 막판에 1씩 더해주기. 인덱스라서
```