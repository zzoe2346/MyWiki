---
tags:
created: 2025-07-27
---
## 잠금 해제 하기
잠금을 획득 후 반드시 잠금을 해제해야 함. 그렇지 않으면 잠금을 시도하는 스레드가 무한정 대기하기 됨.

## 대기 시간 지정하기
잠금 획득을 시도하는 코드는 잠금 구할 때까지 계속 대기하는데, 동시 접근이 많아지면 대기 시간이 길어질 수 있음. 예를 들어 임계 영역의 코드 실행에 0.5초 걸리고 동시에 1000개 스레드가 잠금을 시도하는 상황을 생각해보자. 처음으로 잠금을 획득한 스레드는 0.5 초만에 코드 실행 가능하지만 마지막으로 잠금 획득한 스레드는 499.5초를 기다려야할 수도 있음.

이처럼 대기 시간 길어지는 문제 막기위해서 대기 시간을 지점하는 것.

```java
boolean acquired = lock.tryLock(5, TimeUnit.SECONDS);
```

## 교착 상태(deadlock) 피하기
한 자원에서 다른 자원으로 용량 전송하는 기능 구현한다고 가정. 이 기능을 구현하려면 다음과 같이 두 자원에 대한 잠금 필요.
- 갑 잠금 획득
- 을 잠금 획득
- 갑 용량 감소
- 을 용량 증가
- 을 잠금 해제
- 갑 잠금 해제

> 그림 6.11 보면 교착 상태 볼수잇다

이 데드락도 ==시간 제한을 두면 피할 수 있음==. 5초로 지정하면 5초 뒤에 잠금 획득 실패하면서 교착 상태가 풀리게된다.

교착 상태를 줄이는 다른 방법은 ==순서대로 잠금을 획득==하는 것.

## 라이브락
2명이 지나갈 수 있는 길에서 두 사람이  마주온다. 길을 피하려 둘 다 옆으로 이동했다. 아직 둘 다 마주 보고있다. 그래서 다시 둘 다 옆으로 이동했다. 하지만 여전히 둘 다 마주 보고있다. 두 사람은 이 과정 무한히 한다. 

이렇게 활동하는거 같지만 실제로는 아무것도 하지 않는 상태를 라이브락이라한다. 철학자의 만찬 문제가 대표적인 라이브 락 문제. 라이브락에 빠진 스레드나 프로세스는 뭔가 동작을 한다는 점에서 아무것도 안하고 대기하는 데드락과는 다른것.

우선 순위 두어 해소 가능. 예를 들어 두 사람 마주했을때 우선 순위 낮은 사람이 옆으로가도록. 중재자 둘수도있다. 누가 옆으로 갈지 중재자가 정하는 것. 임의성 주는 법도 있다. 옆으로 이동시 임의 시간만큼 대기했다 이동하게 구현하는 것.

## 기아 상태
작업의 우선 순위가 낮아 실행이 안되는 것
