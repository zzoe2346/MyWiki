---
tags: 
created: 2025-08-01
---
## 경쟁 조건
- 한 대상에 대해 여러 스레드가 동시에 접근하면서 발생하는 동기화 이슈
- 논리적 오류에 해당하지만 컴파일 오류로 확인하기 어려울 수 있음(개발자 역량으로 대응)
- C/C++같은 네이티브 코드도 예외 아니며 Java 경우 C/C++의 포인터를 이용한 참조 경우와 유사

volatile은 메모리 가시성에 관한 문제라 이렇게 멀티스레드의 동시 접근에의한 동시성 문제를 해결못해준다.

✅ **해결함 (가시성)**
```java
private volatile boolean flag = false;

// 스레드1
flag = true;

// 스레드2 - 즉시 변경사항 확인 가능
if (flag) { ... }
```
❌ **해결 안 함 (동시성)**
```java
private volatile int count = 0;

// 여러 스레드에서 동시 실행시 race condition 발생
count++; // 안전하지 않음
```
올바른 해결책
```java
// AtomicInteger 사용
private AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet(); // 원자적 연산

// 또는 synchronized 사용
private int count = 0;
public synchronized void increment() {
    count++;
}
```