---
tags: 
created: 2025-08-10
---
## 상속에 대한 기본 이론
- 객체단위 코드를 재사용(확장)하는 문법
- is-a, has-a 관계로 설명 가능
- 부모/자식, 기본/파생
- 다중 상속은 비허용
- Java 에서 모든 클래스는 Object 의 파생 클래스
- 인스턴스화 할때 부모부터 먼저 생성자 메서드가 호출 되고나서 자식이 생성된다.
## 상속과 생성자 호출 스택
- 파생 클래스 생성자는 가장 **먼저** **호출**되지만 가장 **나중에** **실행**된다.
- 재귀호출과 비슷하게 생성자 함수에 대한 호출 스택이 쌓여 올라가는것이 특징
- **파생 클래스에서 기본 클래스 필드를 정의하는 것은 적절하지 않은 경우가 대부분(때로 심각한 바보짓이 될 수 있음!)**
	- 자기 자신만 보기
## 상속 관계에서 인스턴스 메모리 구조
- 파생 클래스 인스턴스는 부모 클래스(들) 인스턴스를 내부에 포함하는 구조(?검증?)
- 파생 클래스는 부모 클래스의 멤버를 가진 것
	- private 이면 파생 클래스 접근도 차단
	- protected 면 파생 클래스 접근은 허용
## 부모 클래스 생성자 선택
- 파생 클래스 생성자에서 부모 클래스의 여러 생성자 중 원하는 것이 호출되도록 강제화
- super()
## 메서드 재정의(Overriding)⭐️
- 파생 클래스에서 기본 클래스 메서드를 재정의
	- @Override
- 기본 클래스 메서드를 재정의 하는 것은 기존 메서드를 대체하거나 코드를 추가할 목적
- **메서드 재정의 시 실제 인스턴스 형식이 우선**
	- 참조 선언 = new 인스턴스 에서 new 인스턴스를 우선한다는 의미!
- **final 선언으로 파생 클래스에서 메서드가 재정의 되지 못하도록 차단할 수 있다.**
	- public final void getDate()



## 불필요한 호출로 미래와 대화하기
- 부모 클래스에서 정한 함수 호출 관계로 파생 클래스에서 재정의된 메서드가 호출 될 수 있음
- 구조가 정한 흐름을 확장해 내 코드를 추가하는 식으로 올라탈 수 있다.
	- 이게 디자인패턴으로 템플릿 메서드 였던거 같다.

## UML(unified modeling language)
- 모델링 언어 표준으로 클래스 및 연관 관계를 시각화 가능
- Class Diagram, Sequence Diagram 등에대해선 알아야함

## 알아 두면 좋을 동적 바인딩
- 함수와 함수가 서로 호출 피호출 관계가 되는 것이 바인딩
- 바인딩 시점이 Compoile-time 이면 Static binding
- 바인딩 시점이 Run time 이면 Dynamic binding(Lately binding)