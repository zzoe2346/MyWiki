---
tags: 
created: 2025-07-18
---
# 🌳 트리 자료구조 학습 내용 요약

## 1. 트리(Tree) 기본 개념

### 정의 및 특징

- **노드들의 집합**으로 구성된 자료구조
- 각 노드는 **값 + 레퍼런스**로 구성
- **비선형(nonlinear) 구조**
- **계층적 구조**이며 **재귀적 구조**

### 핵심 특징

- ✅ **루트 노드는 하나만 존재**
- ✅ **사이클 없음**
- ✅ **자녀 노드는 하나의 부모 노드만 가짐**

### 주요 용어

|용어|설명|
|---|---|
|**간선(Edge)**|노드와 노드를 연결하는 선 (구현상 레퍼런스)|
|**루트 노드**|트리의 최상단 노드 (시작점)|
|**리프 노드**|자녀 노드가 없는 노드 (외부 노드)|
|**내부 노드**|자녀 노드를 가지는 노드|
|**높이**|노드에서 리프 노드까지 가장 긴 경로의 간선 수|
|**깊이**|루트 노드에서 해당 노드까지 경로의 간선 수|
|**차수(Degree)**|노드의 자녀 노드 수|

---

## 2. 이진 트리(Binary Tree)

### 정의

- **자녀가 최대 2개**인 트리

### 이진 트리의 종류

#### 🔹 균형 이진 트리 (Balanced Binary Tree)

- 모든 노드에서 **왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 최대 1**

#### 🔹 정 이진 트리 (Full Binary Tree)

- 모든 노드가 **자녀가 0개 또는 2개**

#### 🔹 완전 이진 트리 (Complete Binary Tree)

- 마지막 레벨을 제외한 모든 레벨이 꽉 차있고
- **마지막 레벨은 왼쪽부터 채워진** 트리

#### 🔹 포화 이진 트리 (Perfect Binary Tree)

- **모든 레벨이 꽉 찬** 트리

#### 🔹 변질 이진 트리 (Degenerate Binary Tree)

- 모든 부모 노드가 **하나의 자녀만** 가지는 트리

---

## 3. 이진 탐색 트리(BST)

### 정의

- **모든 노드의 좌측 서브트리 < 해당 노드 < 우측 서브트리** 규칙

### 순회 방법

- **전위 순회(Preorder)**: D → L → R
- **중위 순회(Inorder)**: L → D → R
- **후위 순회(Postorder)**: L → R → D

### 시간복잡도

| 연산  | Best | Average  | Worst |
| --- | ---- | -------- | ----- |
| 삽입  | Θ(1) | O(log n) | Θ(n)  |
| 삭제  | Θ(1) | O(log n) | Θ(n)  |
| 검색  | Θ(1) | O(log n) | Θ(n)  |

### 장단점

**장점**:

- 삽입, 삭제가 유연
- 값의 순서대로 순회 가능
- (보통) 빠른 탐색

**단점**:

- 최악의 경우 선형 시간 (한쪽으로 편향)
- 균형이 깨질 수 있음

---

## 4. AVL 트리

### 정의

- **자가 균형 이진 탐색 트리**
- **Balance Factor(BF)가 항상 -1, 0, 1** 중 하나

### Balance Factor

```
BF(x) = h(leftSubTree(x)) - h(rightSubTree(x))
```

### 시간복잡도

|연산|Best|Average|Worst|
|---|---|---|---|
|삽입|Θ(1)|O(log n)|**O(log n)**|
|삭제|Θ(1)|O(log n)|**O(log n)**|
|검색|Θ(1)|O(log n)|**O(log n)**|

### 특징

**장점**:

- **모든 연산이 O(log n) 보장**
- 엄격한 균형 유지

**단점**:

- 삽입/삭제 시 균형 재조정으로 인한 오버헤드

---

## 5. Red-Black 트리

### 정의

- **자가 균형 이진 탐색 트리**
- AVL보다 덜 엄격한 균형 조건

### 특징

- 삽입/삭제 시 **재조정 작업이 AVL보다 적음**
- **실용적인 균형 트리**

---

## 6. B-Tree (B-트리)

### 정의

- **이진 검색 트리를 일반화**한 자료구조
- **2개 이상의 자식**을 가질 수 있음

### 주요 특징

- ✅ **모든 리프 노드가 같은 레벨** (균형 잡힌 트리)
- ✅ **노드 내에 여러 키 저장**
- ✅ **대수확장성**: 트리 깊이가 매우 느리게 증가

### 대수확장성의 효과

- 4차 B-트리에서 **깊이 10 = 최대 100만개 인덱스 저장**
- 차수가 클수록 깊이가 얕아짐

### 시간복잡도

- **탐색**: O(log_m n) (m은 차수)

---

## 7. B+ Tree (B+ 트리)

### 정의

- **B-Tree를 개선**한 자료구조
- **리프 노드 간 연결**이 추가됨

### B-Tree vs B+ Tree 비교

|특징|B-Tree|B+ Tree|
|---|---|---|
|**데이터 저장 위치**|내부 노드에도 가능|**오직 리프 노드**|
|**탐색 속도**|중간에 데이터 발견 가능|**항상 리프까지** (일정한 속도)|
|**범위 쿼리**|복잡하고 느림|**리프 노드 연결로 빠름**|
|**메모리 효율**|낮음|**높음** (리프에만 데이터)|

### 장점

- **메모리 효율성** 우수
- **범위 검색**에 최적화
- **디스크 I/O 감소**

### 단점

- 생성/삭제 시 **연결 관리 오버헤드**

---

## 8. 실제 사용 사례

### 데이터베이스 인덱스

- **MySQL, PostgreSQL, Oracle, SQLite**: B+ Tree 사용
- **MongoDB**: B-Tree로 표기하지만 실제로는 B+ Tree

### 왜 해시 대신 트리를 사용하는가?

- **범위 검색** 때문
- 해시는 정확한 키 검색에만 유리
- 트리는 **범위 쿼리**에 최적화

---

## 📚 학습 포인트

### 트리 선택 기준

1. **단순한 탐색**: 이진 탐색 트리(BST)
2. **균형 보장 필요**: AVL Tree 또는 Red-Black Tree
3. **대용량 데이터**: B-Tree 또는 B+ Tree
4. **범위 검색 중요**: B+ Tree

### 시간복잡도 비교

- **BST**: 최악 O(n), 평균 O(log n)
- **AVL/RB**: 모든 경우 O(log n)
- **B-Tree**: O(log_m n)
- **B+ Tree**: O(log_m n) + 범위 검색 최적화

### 메모리 vs 성능 트레이드오프

- **AVL**: 엄격한 균형, 높은 오버헤드
- **Red-Black**: 실용적 균형, 적은 오버헤드
- **B+ Tree**: 메모리 효율적, 범위 검색 우수