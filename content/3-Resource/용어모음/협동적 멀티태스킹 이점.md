---
created: 2025-06-25
tags:
  - cs/os/term
---
- 자원을 덜 소비한다
	- 컨텍스트 스위칭이 더 가벼움
	- 사용자 수준 스레드라서
	- 협동적 스케줄링에서는 작업이 자식의 생애 주기 스스로 결정하므로 스케줄러가 작업 상태를 감시할 필요 없음
	- 이렇게 구현된 애플리케이현은 단일 스레드(운체 관점에서)인데도 확장성 뛰어남
- 공유 자원에 블로킹 안 일으킴
	- 협동적 멀캐에서는 코드 내 특정 지점에서만 작업이 전환됨
	- 그만큼 공유자원에 블로킹 여지 적다
	- 작업 전환 지점 잘 배치하면 임계 구간에서 간섭 일으키지 않게 가능
- 효율적
	- 혈동적 멀태에선 작업이 실행 중지하고 제어권 넘길 지점 알기에 컨텍스트 스위칭이 더 효율적
		- 하지만, 작업끼리 제어권 주고받는 시점 판단할수있도록 서로를 강하게 의식 해야함
		- 중앙화된 연산이 한 곳에만 있어도 모든 장점 소멸(2장 쇼핑몰 비유 참고)
	- 스케줄러는 어떤 작업이 어디까지 실행해야하는지 알 수 없음
	- 그래서 협동형 멀태에선 시간이 오래걸리는 연산 실행하면 안됨.
	- 꼭필요하다면 주기적으로 제어권 반납해야됨
	- 여러 프로그램 잘게 나눠 수행하면서 서로 제어권 양보한다면 스케줄러로는 불가능한 수준의 동시성 달성 가능
	- 스레드 수십개대신 코루틴 수천 개면 가능

선전혐과 협동형이 상호 배재적인건 아님. 같은 시스템의 서로 다른 추상적 수준에서 함께쓰일수있음. 예를 들어 협동적으로 수행되는 연산을 주기적으로 미리 선점해놓는다면 CPU시간을 더욱 공정히 배분하는 방식도 가능