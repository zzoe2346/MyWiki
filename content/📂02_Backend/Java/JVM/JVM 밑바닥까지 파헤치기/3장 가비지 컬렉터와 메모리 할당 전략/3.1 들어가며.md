- 가비지 컬렉션은 자바 언어에서 처음 도입한 기술이 아님
- MIT 에서 개발된 리스프가 최초
- 리스프의 창시자 존 맥카시는 GC가 처리해야 하는 문제 3가지를 생각해냄
	- 어떤 메모리를 회수?
	- 언제 회수?
	- 어떻게 회수?
- 오늘날 반세기가 지나서 동적 메모리 할당과 가비지 컬렉션 기술이 상당히 성숙
	- 마치 모든것이 자동화 된것 처럼 보임
	- 그럼에도 불구하고 가비지 컬렉션과 메모리 할당의 내부를 이해해야하는 이유는?
- 바로!
	- 다양한 메모리 오버플로와 누수 문제를 해결해야 하는 상황
	- 높은 동시성을 달성하는 데 가비지 컬렉션이 방해가 되는 상황
- 에서 이 '자동화'된 기술을 적절히 모니터링 하고 조율하는 능력이 필요하기 때문!
- PC, 가상 머신 스택, 네이티비 메서드 스택은 스레드와 함께 생성되고 소멸
	- 메서드에 진입하고 빠져나올 때는 스택 메모리에 스택 프레임을 푸시하고 팝함
	- 각 스택 프레임에 할당되는 메모리 크기는 기본적으로 클래스가 만들어 질때 결정됨(JIT 컴파일러가 런타임에 최적화 하는 경우 있지만, 지금은 개념 모델 이야기하니 컴파일 타임에 결정된다고 가정)
	- 따라서, 이 영역의 메모리 할당과 회수는 결정적이라서 어허게 회수할 지는 고민 않아도 됨
	- 메서드 끝나거나 스레드 종료시 자연스럽게 회수됨
- 반면! 자바 힙과 메서드 영역은 불확실한게 많다
	- 같은 인터페이스라해도 구현한 클래스마다 요구하는 메모리 크기 다를 수 있음
	- 하나의 메서드에서도 어떤 조건 분기 실행하느냐에 따라 메모리 요구량 다를 수 있음
	- 프로그램이 어떤 객체 생성할 지, 얼마나 많이 만들지는 오직 런타임만 알 수 있는 것
	- 그래서! 이 메모리 영역들의 할당과 회수는 동적으로 이루어짐
	- 가비지 컬렉터는 바로 이 영역을 관리하는데 집중
	- 이 책에서 메모리 할당과 회수를 말할때의 메모리는 바로 힙과 메서드 영역 지칭