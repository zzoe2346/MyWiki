---
tags: 
created: 2025-08-03
---
## 3.1 실습 환경 구성하기

• 실 습 데 이 터 다 운 로 드 U R L : https://github.com/7ieon/sqLtune
## 3.2 실행 계획 수행
>124page

실행 계획이란 말 그대로 SQL 문으로 요청한 데이터를 어떻게 불러올 것인지에 대한 계획, 즉 경로를 의미한다.

지름길로 가서 빠르게 데이터 찾을 것인지, 지름길 있어도 멀리 돌아가서 찾을 것인지 미리 확인이 가능하다.

### 3.2.1 기본 실행 계획 수행
`EXPLAIN, DESCRIBE, DESC` 로 실행 계획 조회 가능하다.

#### MySQL의 실행 계획 수행
mariaDB에 비해 filtered 열이 추가되면서 더 많은 정보를 보여준다.

#### MariaDB 실행 계획 수행
10.0.5 이상에서는 UPDATE, DELETE 문에서도 실행 계획 확인이 가능하다.
### 3.2.2 기본 실행 계획 항목 분석
실행 계획에 있는 id, select_type 등 키워드를 명확히 알아야된다. 그래야 비효율적이 아닌지, 어떻게 튜닝을 해야할 지에 관한 방향을 잡을 수 있기 때문이다.

#### id
실행 순서를 표시하는 숫자. 수행되는 차례를 ID로 표시한 것으로, 조인할 때는 똑같은 ID 가 표시된다. 즉, id가 작을수록 먼저 수행된 것이고 id가 같다면 두 개 테이블의 조인이 이루어졌다고 해석할 수 있다.
#### select_type
SELECT 문의 유형을 출력하는 항목. select가 단순히 FROM에 위치한건지, 서브쿼리인지, UNION으로 묶인 select 인지 등의 정보를 제공한다. 다음을 통해 자주 출력되는 select_type 정보를 알아보자.

**SIMPLE**

union 또는 내부 쿼리가 없는 select란 의미. 단순한 select 구문만으로 작성된 경우를 가리킨다.

**PRIMARY**

서브쿼리가 포함된 SQL 문이 있을때 첫 번째 SELECT 문에 해당하는 구문에 표시되는 유형. 즉, 서브쿼리를 감싸는 외부 쿼리거나, UNION이 포함된 SQL에서 첫 번째로 SELECT 키워드가 작성된 구문에 표시된다. 128 페이지 참고!

**SUBQUERY**

독립적으로 수행되는 서브쿼리를 의미.

**DRIVED**

FROM 절에 작성된 서브쿼리라는 의미. 즉, FROM 절의 별도 임시 테이블인 **인라인 뷰를 말한다**. 

**UNION**

UNION 및 UNION ALL 구문으로 합쳐진 SELECT 문에서 첫 SELECT 구문 제외한 이후의 select 구문에 해당하는걸 나타낸다. 이때 union 구문의 첫 select 절은 PRIMARY 유형으로 출력된다.

**UNION RESULT**

UNION ALL 아닌 UNION 구문으로 SELECT 절을 결합했을 때 출력된다. union은 출력 결과에 중복이 없는 유일한 속성을 가지므로 각 select 절에서 데이터 가져와 정렬하여 중복 체크하는 과정을 거친다. **따라서 union result는 별도의 메모리 또는 디스크에서 임시 테이블을 만들어 중복을 제거하겠다는 의미로 해석할 수 있다**. 

한편 union 으로 결합되지 전의 각 select 문이 중복되지 않는 결과가 보장될때는 union 보다 union all 구문으로 변경하는 SQL 튜닝을 수행한다.

**DEPENDENT SUBQUERY**

union or union all을 사용하는 서브쿼리가 메인 테이블의 영향을 받는 경우. UNION 으로 연결된 단위 쿼리들 중에서 처음으로 작성한 단위 쿼리에 해당되는 경우이다. **즉, UNION으로 연결되는 첫 번째 단위 쿼리가 독립적으로 수행되지 못하고 메인 테이블로 부터 값을 하나씩 공급받는 구조(AND 사원1.사원번호 = 관리자.사원번호)이므로 성능적으로 불리하여 SQL이 튜닝대상이 된다.**

**DEPENDENT UNION**

UNION or UNION ALL 시용하는 서브쿼리가 메인 테이블의 영향을 받는 경우. UNION으로 연결된 단위 쿼리 중 첫 번째 단위 쿼리를 제외하고 두 번째 단위 쿼리에 해당하는 경우. 즉, UNION으로 연결되는 두 번째 이후의 단위 쿼리가 독립적으로 수행되지 못하고 메인 테이블로부터 값을 하나씩 공급받는 구조이므로 이 또한 위와 같이 성능적으로 불리하여 튜닝의 대상이 된다.

**UNCACHEABLE SUBQUERY**

말 그대로 메모리에 상주하여 재활용되어야할 서브쿼리가 재사용되지 못할 때 출력되는 유형. 이런 유형은
1. 해당 서브쿼리 안에 사용자 정의 함수나 사용자 변수 포함
2. RAND(), UUID() 함수 등을 사용하여 매번 조회 시마다 결과가 달라지는 경우
에 해당한다.

만약 자주 호출되는 쿼리라면 메모리에 서브쿼리 결과가 상주할 수 있도록 변경하는 방향으로 튜닝을 고려해볼 수 있다. 135페이지 참고.

**MATERIALIZED**

IN 절 구문에 연결된 서브쿼리가 임시 테이블을 생성한 뒤, 조인이나 가공 작업을 수행할 때 출력되는 유형. 즉, IN 절의 서브쿼리를 임시 테이블로 만들어서 조인 작업을 수행하는 것이다. 136페이지 참고!

#### table
말 그대로 테이블명을 표시하는 항목. 실행 계획 정보에서 테이블명이나 테이블 별칭(alias)를 출력하며, 서브쿼리나 임시 테이블을 만들어서 별도의 작업을 수행할 때는 \<subquery#> 나 \<derived#>라고 출력된다.

![[SCR-20250806-hazd.png]]
예제를 보자.  쿼리 수행 결과 첫 번째 행의 table 열에는 \<derived2>라고 출력되었고 ID 값은 1이다. 두 번째 행의 ID 값 역시 마찬가지로 1인 것으로 보아,  \<derived2>와 사원 테이블이 조인했으리라 해석이 된다. 여기서  \<derived2>는 ID가 2인 테이블이라는 뜻으로 사실상 급여 테이블을 의미한다. 즉, FROM 절의 서브쿼리 구문으로 작성된 급여 테이블과 사원 테이블이 조인했다고 이해할 수 있다.

#### partitions
실행계획의 부가 정보. 데이터가 저장된 논리적인 영역을 표시하는 항목이다. 사전에 정의한 전체 파티션 중 특정 파티션에 선택적으로 접근하는 것이 쿼리 성능 측면에서 유리하다. 만약 너무 많은 영역의 파티션에 접근하는 것으로 출력된다면 파티션 정의를 튜닝해야 할 것이다.
#### type
테이블의 데이터를 어떻게 찾을지에 대한 정보를 제공하는 항목. 테이블을 처음 부터 끝까지 전부 확인할 지 아니면 인덱스로 바로 데이터를 찾아갈지 등을 해석할 수 있다.

**SYSTEM**

테이블에 데이터가 없거나 한 개만 있는 경우로, 성늘상 최상의 type.

**CONST**

조회되는 데이터가 단 1건일 때 출력되는 유형. 성능상 매우 유리한 방식. 고유 인덱스나 기본 키를 사용하여 단 1건의 데이터에만 접근하면 되니 속도나 리소스 측면에서 지양해야 할 타입.

**eq_ref**

조인이 수행될 때 드리븐 테이블의 데이터에 접근하며 고유 인덱스 또는 기본 키로 단 1건의 데이터를 조회하는 방식. 드라이빙 테이블과 조인 키가 드리븐 테이블에 유일하므로 조인이 수행될 때 성능상 가장 유리한 경우라고 할 수 있다.

**ref**

앞서 설명한 eq_ref 유형과 유사한 방식으로, 조인을 수행할 때 드리븐 테이블의 데이터 접근 범위가 2개 이상일 경우를 의미한다. 즉, 드라이빙 테이블과 드리븐 테이블이 조인을 수행하면 일대다 관계가 되므로, 드라이빙 테이블 1개 값이 드리븐 테이블에서는 2개 이상의 데이터로 존재한다. 이때 기본 키나 고유 인덱스를 활용하면 2개 이상의 데이터가 검색되거나, 유일성이 없는 비고유 인덱스를 사용하게 된다. 드리븐 테이블의 양이 적을때는 성능 저하를 크게 우려하지 않아도 되지만, 데이터양이 많다면 접근해야 할 데이터 범위가 넓어져 성능 저하의 원인이 되는지 확인해야 한다. 한편으로는 =, <, > 등의 연산자를 사용해 인덱스로 생성된 영을 비교할 때도 출력된다.

**ref_or_null**

ref 유형과 유사하지만 IS NULL 구문에 대해 인덱스를 활용하도록 최적화된 방식이다. MySQL, MariaDB는 NULL에 대해서도 인덱스를 활용하여 검색할 수 있으며, 이때 NULL은 가장 앞에 정렬된다. 테이블에서 검색할 NULL 데이터양이 적다면 ref_of_null 방식을 활용했을때 효율적인 쿼리문이 될 것이나, 검색할 NULL 데이터양이 많다면 튜닝의 대상이 될 것이다.

**range**

테이블 내의 연속된 데이터 범위를 조회하는 유형. =, <>, >, >=, IS NULL, BETWEEN 또는 IN 으로 범위 스캔을 수행하는 방식. 주어진 데이터 범위 내에서 행 단위 스캔을 하지만, 스캔 범위가 넓으면 성능 저하 요인이 될 수 있느니 튜닝의 대상이 된다.

**fulltext**

텍스트 검색을 빠르게 처리하기 위한 전문 인덱스(full text index)를 사용하여 데이터에 접근하는 방식

**index_merge**

말 그대로 결합된 인덱스들이 동시에 사용되는 유형. 즉, 특정 테이블에 생성된 두 개 이상의 인덱스가 병합되어 동시에 적용된다. 이때 전문 인덱스는 제외된다.

**index**

type항목의 index 유형은 인덱스 풀 스캔을 의미한다. 즉, 물리적인 인덱스 블록을 처음부터 끝까지 훓는 방식. 이때 데이터를 스캔하는 대상이 인덱스라는 점이 다를 뿐, 이어서 설명할 ALL 유형과 유사하다.

**ALL**

테이블을 처음부터 끝까지 읽는 테이블 풀 스캔 유형. ALL 유형은 활용할 수 있는 인덱스가 없거나, 인덱스를 활용하는게 오히려 비효율적이라고 옵티마이저가 판단했을 때 선택된다.

ALL 일때는 인덱스 추가하거나 기존 인덱스를 변경하여 인덱스를 활용하는 방식으로 튜닝이 가능하나, 전체 테이블 중 10~20% 이상 분량의 데이터를 조회할 때는 ALL 이 오히려 성능상 유리할 수 있다.
#### possible_keys
옵티마이저가 쿼리문을 최적화하고자 사용할 수 있는 인덱스 목록을 출력한다. 다만 실제 사용한 인덱스가 아닌, 사용할 수 있는 후보군의 기본 키와 인덱스 목록만 보여줄 뿐이다.
#### key
옵티마이저가 쿼리를 최적화 하고자 사용한 PK 또는 인덱스명을 의미한다. 어느 인덱스로 데이터를 검색했는지 알 수 있으므로, 비효율적인 인덱스를 사용했거나 인덱스 자체를 사용하지 않았다면 튜닝의 대상이 된다.
#### key_len
인덱스 쓸 때는 인덱스 전체를 쓰거나 일부 인덱스만 쓴다. key_len은 이렇게 사용한 인덱스의 바이트 수를 의미한다. UTF-8 캐릭터셋 기준으로 INT 데이터 유형은 단위당 4바이트, VARCHAR은 단위당 3바이트다.
#### ref
reference 의 약자. 조인을 수행할 때 어떤 조인 조건으로 해당 테이블에 액세스되었는지 알려주는 정보.
#### rows
쿼리문을 수행하고자 접근하는 데이터의 모든 행 수를 나타내는 **예측 항목**. 즉, 디스크에서 데이터 파일을 읽고 메모리에서 처리해야 할 행수를 예상하는 값이고, 수시로 변동되는 MySQL의 통계정보를 참고하여 산출되는 값이므로 정확하진 않다. 그리고 **최종 출력될 행 수가 아니라는 점에 유의하자.**

#### filtered
SQL 문을 통해 **DB 엔진으로 가져온 데이터 대상**으로 ==필터 조건에 따라 어느 정도의 비율로 데이터를 제거했는지 의미하는 항목==이다. 예를 들어 DB 엔진으로 100건의 데이터를 가져왔다 가정하면, 이후 WHERE 절의 사원번호 BETWEEN 1 AND 10 조건으로 100거의 데이터가 10건으로 필터링 된다. 이처럼 100 -> 10 으로 필터링 되었으므로 filtered 에는 10 이라는 정보가 출력될 것. 단위는 %

![[SCR-20250806-hrpv.jpeg]]
#### extra
SQL 문을 어떻게 수행할 것인지에 관한 추가 정보를 보여주는 항목. 이러한 부가적인 정보들은 세미콜론(;)으로 구분하여 여러 정보 나열할 수 있으며 30여 가지 항목으로 정리할 수 있다.

이후 현업에서 자주 만나게 될 extra 정보 몇가지를 설명한다. MySQL에서는 extra에서 수행되는 정보가 모두 출력이 안되니 어디까지나 참고하는 수준에서 해석하는것이 좋다.
**Distinct**

**Using where**

**Using temporary**

**Using index**

**Using filesort**

**Using join buffer**

**Using union/ Using intersect/ Using sort_union**

**Using index condition**

**Using index condition(BKA)**

**Using index for group-by**

**Not exists**
### 3.2.3 좋고 나쁨을 판단하는 기준

### 3.2.4 확장된 실행 계획 수행
## 3.3 프로파일링
## 3.4 마치며 