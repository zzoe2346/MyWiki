---
tags: 
created: 2025-09-12
---
- 사람의 머리 역할 -> MySQL Engine
- 손발 역할 -> Storage Engine
## 4.1  MySQL 엔진 아키텍처
- MySQL 서버는 다른 DBMS와 비교해 구조가 독특한 편
- 이 구조 때문에 장점도 있지만 단점 또한 존재
### 4.1.1 MySQL의 전체 구조
그림

- MySQL은 일반 상용 RDBMS 같이 대부분 프로그래밍 언어로부터 접근 지원
- MySQL 서버는 MySQL 엔진과 스토리지 엔진으로 구분 가능
- 이 책에서는 쿼리파서, 옵티마이저 등 기능을 스토리지 엔진과 구분하고자 이런 분류를 하였음
#### 4.1.1.1 MySQL 엔진
MySQL 엔진은 
- 커넥션 핸들러: 클라로 부터의 접속 및 쿼리 요청을 처리
- SQL 파서
- 전처리기
- 옵티마이저: 쿼리의 최적화된 실행을 위함
#### 4.1.1.2 스토리지 엔진
- 실제 데이터를 디스크에 저장하거나 읽어오는 역할
- MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개 동시 사용 가능
- 예를 들면 `CREATE TABEL test_table (fd1 INT, fd2 INT) ENGINE=INNODB` 
- 각 엔진은 성능 향상위해 키 캐시(MyISAM), 버퍼 풀(InnoDB)같은 기능을 내장하고 있다
#### 4.1.1.3 핸들러 API
- MySQL 엔진의 쿼리 실행기에서 데이터 읽거나 쓸때는 각 스토리지 엔진에 쓰기/읽기 요청을 하는데 이런 요청을 핸들러(Handler) 요청
- 여기서 사용되는 API를 핸들러 API 라 지칭
- 핸들러 API로 스토리지 엔진과 MySQL 엔진이 데이터 주고 받는다
- 핸들러 API로 얼마나 많은 데이터(레코드) 작업이 있었는지 확인하려면 `SHOW GLOBAL STATUS LIKE 'Handler%'` 로 확인 가능
### 4.1.2 MySQL 스레딩 구조
\[그린2 98p]
- 스레드 기반으로 동작하는 MySQL
- 포그라운드, 백그라운드 스레드로 구분된다
- MySQL에서 실행 중인 스레드 확인하려면 `SELECT thread_id, name, type, processlist_user, processlist_host FROM performance_schema.threads ORDER BY type, thread_id`
#### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)
- 포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라 수 만큼 존재
- 클라 사용자가 작업 마치고 커넥션 종료하면 해당 커넥션 담당하던 스레드는 다시 스레드 캐시(Thread cache)로 되돌아감
- 이때 이미 스레드 캐시에 일정 개수 이상의 대기 중 스레드가 있으면 스레드 캐시에 넣지 않고 스레드 종료시켜 일전 개수의 스레드만 캐시에 존재하게 함
- 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 `thread_cache_size`로 정함
- 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져옴
- 버퍼나 캐시 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와 작업을 처리
- MyISAM 테이블은 디스크 쓰기 까지 포그라운드 스레드가 처리(MyISAM도 지연 스기 있지만 일반적이지 않다)
- InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리함
> MySQL에서 의미상 사용자 스레드 == 포그라운드 스레드

#### 4.1.2.2 백그라운드 스레드
### 4.1.3 메모리 할당 및 사용 구조

## 4.2 InnoDB 스토리지 엔진 아키텍처
## 4.3 MyISAM 스토리지 엔진 아키텍처
## 4.4 MySQL 로그 파일
