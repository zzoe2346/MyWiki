---
tags: 
created: 2025-08-13
---
이제까지 신뢰적인 데이터 전송의 원칙을 다루었다. 이제 TCP~! 연결형, 신뢰적인 트랜스포트 프로토콜을 공부해보자.

## 3.5.1 TCP 연결
데이터 전송을 보장하는 파라미터들을 각자 설정하기 위해 세그먼트들을 보내야한다. 그래야 핸드셰이크가 되니깐.

TCP 연결은 회선 교환 네트워크에서와 같은 종단 간의 TDM이나 FDM이 아니다. 대신 연결은 두 종단 시스템의 TCP에 존재하는 상태를 공유하는 논리적인 것이다. TCP는 오직 종단에서만 동작하고 중간의 네트워크 요소(라우터, 링크 계층 스위치)에선 동작 않으므로, 중간의 네트워크 요소들은 TCP 연결 상태를 유지하지 않는다. 사실, 중간 라우터들은 TCP 연결을 전혀 감지 못한다. 즉, 이들은 연결은 보지 못하고 데이터그램만 본다.

TCP 연결은 전이중 서비스(full-duplex service)를 제공한다. 만약 호스트 a와 b사이에 TCP 연결이 있다면, 애플리케이션 계층 데이터는 b -> a, a -> b 가 동시에 가능하다! 또한 TCP 연결은 항상 단일 송신자와 단일 수신자 사이의 점대점이다. 단일 송신 동작으로 한 송신자가 여러 수신자에게 데이털르 전송하는 멀티캐스팅은 TCP에서는 불가하다. TCP에서 두 호스트는 동료고 셋은 만원이다.

이제 TCP 연결이 어케 설정되는지 보자. 한 호스트에서 동작하는 프로세스가 다른 호스트의 프로세스와 연결을 초기화하기를 원한다고 가정하자. 클라 프로세스는 서버의 프로세스와 연결을 설정하기 원한다고 TCP 클라에게 먼저 알린다. 2.7.2에서 파이썬 클라 프로그램에 다음 명령으로 이 기능 수행했음.

`clientSocket.connect((serverName, serverPort))`

클라의 트랜스포트 계층은 서버의 TCP와의 TCP 연결 설정을 진행한다. 이 절의 마지막에 연결 설정 절차를 자세히 설명함. 지금은 클라가 먼저 특별한 TCP 세그먼트를 보낸다는것을 아는 정도로 충분. 서버는 두 번째 특별한 TCP 세그먼트로 응답. 마지막으로, 클라가 세 번째 특별한 세그먼트로 응답한다. 처음 2개의 세그먼트에는 페이로드, 즉, 앱 계층 데이터가 없다. 세 번째 세그먼트는 페이로드를 포함할 수 있다. 두 호스트 사이에 3개의 세그먼트가 보내지므로 흔히 three way handshake 라 부른다.

일단 TCP 연결이 되면, 두 앱 프로세스는 서로 데이터를 보낼 수 있다. 클라 프로세스에서 서버 프로세스로의 데이터 송신을 고려해보자. 클라 프로세스는 소켓을 통해 데이터의 스트림을 전달한다. 데이터가 소켓 통해 전달되면, 이제 데이터는 클라에서 동작하고 있는 TCP에 맡겨진다. 그림 3.28에 보이듯이 TCP는 초기 세 방향 핸드셰이크 동안 준비된 버퍼중의 하나인 송신 버퍼로 데이터 보낸다. 때때로 TCP는 송신 버퍼에서 데이터 묶음을 만들어 네트워크로 보낸다. TCP 명세서(RFC 793)에서 TCP '자신이 편한 대로 세그먼트의 데이터를 전송'해야 한다고 기술하고 있으며, TCP가 언제 버퍼된 데이터를 전송해야하는지는 미기술되어있다. 세그먼트로 모아 담을 수 있는 최대 데이터 양은 최대 세그먼트 크기(maximum segement size, MSS)로 제한된다. MSS는 일반적으로 로컬 송신 호스트에 의해 전송될 수 있는 가장 큰 링크 계층 프레임의 길이(최대 전송 단위 maximum trasmission unit, MUT)에 의해 일단 결정되고, 후에 TCP 세그먼트와 TCP/IP 헤더 길이가 단일 링크 계층 프레임에 딱 맞도록 하여 정해진다. 이더넷과 PPP 링크 계층 프로토콜은 모두 1500 바이트의 MTU 갖는다. 따라서 MSS의 일반적 값은 1460바이트다. 출발지에서 목적지까지 모든 링크상에 전송될 수 있는 가장 큰 링크 계층 프레임인 경로 MTU를 찾고 이 경로 MTU 값에 근거한 MSS 설정을 위한 방식들도 제안되고 있다. MSS가 헤더를 포함하는 TCP 세그먼트의 최대 크기가 아니라, 세그먼트에 있는 앱 계층 데이터에 대한 최대 크기라는 점 주의(혼동되지만 우린 이 용어 써야됨)

![[SCR-20250813-rfpn.jpeg]]

TCP는 TCP 헤더와 클라이언트 데이터를 하나로 짝지어 TCP 세그먼트를 구성한다. TCP가 세그먼트를 수신했을 때, 그림 3.28처럼 세그먼트 데이터는 TCP 연결의 수신 버퍼에 위치한다. 앱은 이 버퍼로부터 데이터 스트림을 읽는다. 연결의 양 끝은 각각 자신의 송신 버퍼와 수신 버퍼 가지고있다.

TCP 연결은 한쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결과 다른 쪽 호스트에서의 버퍼, 변수, 소켓 연결의 집합으로 이루어진다는 사실을 알 수 있다.

이런 버퍼, 변수 같은건 호스트 간 네트워크 요소인 라우터, 스위치, 리피터의 연결에는 해당 안된다.

## 3.5.2 TCP 세그먼트 구조
TCP 세그먼트는 헤더 필드 + 데이터 필드. MSS는 세그먼트의 데이터 필드의 크기를 제한한다. TCP가 이미지 같은 큰 파일 전송할 때, 일반적으로 MSS 크기로 파일을 분절한다.(통상 MSS 보다 작은 마지막 분절은 제외). 그러나 많은 대화식 앱은 MSS보다 작은 양의 데이터를 전송한다. 예를 들면, 텔넷과 ssh에 전송되는 세그먼트는 단지 21바이트 정도.

그림 3.29는 TCP 세그먼트의 구조를 보여준다. UDP 처럼 헤더는 상위 계층 앱으로부터 다중화와 역다중화를 하는데 사용되는 출발지와 목적지 포트번호를 포함한다. 또 UDP 처럼 헤더는 체크섬 필드를 포함한다. TCP 세그먼트 헤더는 또한 다음과 같은 필드를 포함한다.
![[SCR-20250814-gqoe.jpeg]]
- 32 비트 순서 번호 필드와 32비트 확인응답 번호 필드는 전에 논의한것처럼 신뢰적인 데이터 전송 서비스 구현에서 TCP 송신자와 수신자에 의해 사용된다.
- 16비트 수신 윈도 필드는 흐름 제어에 사용. 이는 수신자가 받아들이려는 바이트의 크기를 나타내는 데 사용된다는 것을 곧 보게 될 것
- 4비트 헤더 길이 필드는 32비트 워드 단위로 TCP 헤더의 길이를 나타냄. TCP 헤더는 TCP 옵션 필드 덕에 가변적인 길이가 될 수 있다. 일반적으로 옵션 필드는 일반적인 TCP 길이가 20바이트 되도록 비어있다.
- 선택적, 가볍적인 길이의 옵션필드는 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 이용된다. 타임스탬프 옵션 또한 정의됨.
- 플래그 필드는 6비트를 포함한다. ACK 비트는 확인응답 필드에 있는 값이 유용함을 가리키는데 사용. 즉, 이 세그먼트는 성공적으로 수신된 세그먼트에 대한 확인응답을 포함한다. RST, SYN, FIN 비트는 연결 성정, 해제에 사용된다. PSH 비트가 설정될 때, 이건 수신자가 데이터를 상위계층으로 즉시 전달해야한다는걸 가리킨다. 마지막으로, URG 비트는 이 세그먼트에서 송신 측 상위 계층 개체가 '긴급'으로 표시하는 데이터임을 가리킨다. 이 긴급 데이터의 마지막 바이트의 위치는 16비트 긴급 데이터 포인터 필드에 의해 가리켜진다. TCP는 긴급 데이터가 존재할 때 수신 측 상위계층 개체에 통지해야하고 긴급 데이터의 끝에 대한 포인터를 전달한다.(PSH, URG 그리고 긴급 데이터에 대한 포인터는 실제 사용되지 않지만 완벽하게 하도록 이런 필드를 언급한것)

### 순서 번호와 확인응답 번호
48~

- TCP 헤더에서 가장 중요한 필드 두 가지는 순서 번호 필드와 확인 응답 번호 필드.
- TCP는 데이터를 구조화되어 있지 않고 단지 순서대로 정렬되어 있는 **바이트 스트림** 으로 본다.
- 세그먼트에 대한 순서 번호 == 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호
- 호스트가 자신의 세그먼트에 삽입하는 확인응답 번호는 상대 호스트로 부터 기대하는 다음 바이트의 순서 번호
- TCP는 스트림에서 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인응답하기 때문에, TCP는 누적 확인응답(cumulative acknowledgement)를 제공한다고 한다.
- 세그먼트가 순서에 맞지 않게 수신되었을 때 행동 후보
	- 1. 수신자가 순서 안 맞는 세그먼트 버린다
	- 2. 순서 바뀐거 들고 있고, 빈 공간에 채울 세그먼트 기다린다(이쪽이 효율적이며, 실제로 선택한 방식) 
- 실제 구현에서 TCP 의 시작 순서 번호는 각 호스트마다 랜덤이다.

### 텔넷: 순서 번호화 응답확인 번호 사례연구

49~

- 텔넷은 원격 로그인을 위해 사용되는 유명한 애플리케이션 계층 프로토콜
- TCP 상에서 동작
- 텔넷은 대화형 애플리케이션
- 패스워드를 포함한 텔넷 연결에서 전송된 데이터는 암호화가 되지 않아서 도청 공격에 취약하므로 텔넷보다 SSH 프로토콜이 선호됨
![[SCR-20250814-hkos.jpeg]]
- Seq는 송신자가 보내는 데이터 바이트의 번호를 나타내는 32비트 숫자
	- 데이터의 순서를 보장하고, 재전송 시 위치를 식별
- Ack는 수신자가 다음에 받아야 할 바이트 번호를 알려주는 32비트 숫자
	- "여기까지 받았으니 그 다음부터 보내세요"라는 의미
## 3.5.3 왕복 시간(RTT) 예측과 타임아웃
### 왕복 시간 예측
### 재전송 타임아웃 주기의 설정과 관리
## 3.5.4 신뢰적인 데이터 전송
- 네트워크 계층은 비신뢰적
- 인터넷 프로토콜은 데이터그램 전달 보장하지 않는다.
- 데이터그램 순서대로 전달 보장하지 않는다.
- TCP는 IP의 비신뢰적인 최선형 서비스에서 신뢰적인 데이터 전송 서비스를 제공한다.
	- 프로세스가 자신의 수신 버퍼로부터 읽은 데이터 스트림이 손상, 손실, 중복이 없고 순서가 유지됨을 보장한다.
- 이 장에서 설명하는 TCP는 단일 재전송 타이머를 쓴다. 각각의 세그먼트마다 타이머 다는게 아닌. 타이머 관리 오버헤드 방지 차원
- 송신자의 SendBase 는 수신 확인응답이 확인되지 않은 가장 오래된 바이트의 순서 번호(그러므로 Sendbase - 1 은 수신자에게서 정확하게 차례대로 수신되었음을 알리는 마지막 마지막 바이트의 순서 번호)
### 몇 가지 흥미로운 시나리오
![[SCR-20250814-hrwg.jpeg]]
![[SCR-20250814-hrxy.jpeg]]