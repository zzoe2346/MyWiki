---
tags: 
created: 2025-07-31
---
## JVM과 컴퓨터 구조
==JVM은 H/W + OS 같은 역할을 모두 수행==

- C/C++ 개발자 관점의 JVM은 사용자 모드 응용 프로그램
- CPU 캐시 등 실제 H/W 수준 통제하는 대부분의 코드는 C/C++ 기반 코드이며 Java에서는 불가능
	- CPU 캐시 메모리 통제 API는 Native method로 구현
	- Java 응용 프로그램이 특정 환경에 종속되지 않기 위한 것
## JVM 메인 메모리와 작업 메모리
- Java 메모리 모델의 핵심 목표는 변수에 접근(읽기, 쓰기) 규칙을 정하는 것
	- 메인 메모리와 작업 메모리로 구분
	- 지역변수와 매개변수는 제외(Stack 사용)
- 모든 변수는 JVM 메인 메모리에 저장된다고 규정
- 작업 메모리는 스레드가 사용하는 **변수의 사본**이 저장되며 ==스레드 내부에 연산은 작업 메모리에만 반영==
	- 스레드마다 독립적인 작업 메모리 존재하며 접근 불가
	- 스레드는 JVM 메인 메모리 직접 접근 불가

이러면 메인 메모리 변수와 작업 메모리의 번수 불일치는? 이제 알아보자.

## JVM 메인 메모리와 작업 메모리

- 읽기(READ) 
	- 메인 메모리에서 변수 값을 읽어 작업 메모리로 전송 하는 것
- 적재(LOAD)
	- 메인 메모리가 전송한 값을 작업 메모리(사본)에 저장하는 것
- 저장(Store)
	- 작업 메모리 변수의 값을 메인 메모리로 전송하는 것
- 쓰기(Write)
	- 작업 메모리가 보내준 값을 메인 메모리 변수에 반영(저장)하는 것
위 4가지 절차를 성공하면 나머지 스레드들이 이 변경된결 즉시 반영하지 않는다. 필요할때 반영한다. Lazy

동기화는 항상 일어나지 않고 필요할 때 일어난다.