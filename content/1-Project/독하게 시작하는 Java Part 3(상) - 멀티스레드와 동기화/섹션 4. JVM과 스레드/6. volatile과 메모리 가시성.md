---
tags:
  - ⭐️⭐️⭐️
created: 2025-08-01
---
## volatile 갖는 의미
- 멀티스레드 환경에서 여러 스레드가 접근하는 변수(메모리)에 대해 가시성(visibility) 제공
	-  스레드 코드가 해당 변수에서 값을 읽을 때마다 메인 메모리와 동기화
- C/C++ 에서는 **컴파일러 최적화 규칙을 적용하지 않기 위해 사용**
	- Java 에서 성능 항샹을 위한 명령어 재정렬 최적화를 적용하지 않음(최적화 방지)
	- 눈에 보이는 코드와 실제 실행 흐름은 다를 수 있음.

최적화의 본질적의미는 하지않아도 될 일을 하지 않게 하는 것. 

---

- **volatile**: 가시성만 보장
- **synchronized**: 가시성 + 상호배제 둘 다 보장

volatile은 메모리 가시성에 관한 문제라 이렇게 멀티스레드의 동시 접근에의한 동시성 문제를 해결못해준다.

✅ **해결함 (가시성)**
```java
private volatile boolean flag = false;

// 스레드1
flag = true;

// 스레드2 - 즉시 변경사항 확인 가능
if (flag) { ... }
```
❌ **해결 안 함 (동시성)**
```java
private volatile int count = 0;

// 여러 스레드에서 동시 실행시 race condition 발생
count++; // 안전하지 않음
```
올바른 해결책
```java
// AtomicInteger 사용
private AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet(); // 원자적 연산

// 또는 synchronized 사용
private int count = 0;
public synchronized void increment() {
    count++;
}
```
